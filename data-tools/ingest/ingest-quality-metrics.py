import csv
import os
import sys
from configparser import ConfigParser

import psycopg2

dbcfg = ConfigParser()
dbcfg.read('../../config/database.ini')

try:
    file_name = sys.argv[1]
    variable = sys.argv[2]
except Exception as e:
    print('Usage: python ingest-quality-metrics.py FILENAME VARIABLE')
    print(e)
    sys.exit(1)

try:
    conn = psycopg2.connect("dbname='" + dbcfg.get('postgres', 'database') +
                            "' user='" + dbcfg.get('postgres', 'username') +
                            "' host='" + dbcfg.get('postgres', 'host') +
                            "' password='" + dbcfg.get('postgres', 'password') +
                            "' port='" + dbcfg.get('postgres', 'port') +
                            "'")
except psycopg2.OperationalError as e:
    print(e)
    sys.exit(1)

# if exposure_list doesn't have the has_quality_metric column, add it and default to FALSE
sql = "SELECT column_name " \
      "FROM information_schema.columns " \
      "WHERE table_name='exposure_list' " \
      "AND column_name='has_quality_metric';"
cur = conn.cursor()
cur.execute(sql)
if not cur.fetchall():
    print('Adding column: data_quality')
    sql_add = "ALTER TABLE exposure_list ADD COLUMN IF NOT EXISTS has_quality_metric BOOLEAN DEFAULT FALSE;"
    print('  -- ' + sql_add)
    cur = conn.cursor()
    cur.execute(sql_add)
    conn.commit()
    cur.close()
else:
    print('has_quality_metric: Already defined')

# Additional data quality metrics generated by CMAQ have been commented out, but could be activated at a later date
sql = "SELECT variable FROM quality_metrics_list;"
cur = conn.cursor()
cur.execute(sql)
variables = cur.fetchall()
dq_metrics = []
for var in variables:
    dq_metrics.append(str(var[0]))

dq_dict = {}
with open(file_name) as f:
    reader = csv.reader(f)
    headers = next(reader)
    headers.pop(0)
    prefix = os.path.commonprefix(headers)
    prefix = prefix.lower()
    print(prefix)
    print(headers)
    for dq in dq_metrics:
        metric = "\n".join(s for s in headers if prefix + dq.lower() == s.lower())
        if metric:
            dq_dict[dq] = metric

# insert or update quality metrics in quality_metrics_data for the provided variable
with open(file_name) as f:
    reader = csv.DictReader(f)
    for row in reader:
        # check if date-time row already exists
        sql = "SELECT * FROM quality_metrics_data WHERE utc_date_time = '" + row['Date'] + "';"
        cur = conn.cursor()
        cur.execute(sql)
        if not cur.fetchall():
            dq_vars = ''
            dq_vals = '\'' + str(row['Date']) + '\', '
            for dq in dq_dict:
                dq_vars += variable + '_' + dq + ', '
                dq_vals += str(row[str(dq_dict[dq])]) + ', '
            sql_stmt = "INSERT INTO quality_metrics_data " \
                       "(utc_date_time, " + dq_vars[:-2] + ") " \
                                                           "VALUES (" + dq_vals[:-2] + ");"
        else:
            dq_vals = ''
            for dq in dq_dict:
                dq_vals += variable + '_' + dq + ' = ' + str(row[str(dq_dict[dq])]) + ', '
            sql_stmt = "UPDATE quality_metrics_data " \
                       "SET " + dq_vals[:-2] + " " \
                                               "WHERE utc_date_time = '" + row['Date'] + "';"
        print('  -- ' + sql_stmt)
        cur.execute(sql_stmt)
        conn.commit()
        cur.close()

# set quality metrics flags to TRUE for variable in quality_metrics_list
for dq in dq_dict:
    sql_update = "UPDATE quality_metrics_list " \
                 "SET " + variable + " = TRUE " \
                                     "WHERE variable = '" + dq + "';"
    print('  -- ' + sql_update)
    cur = conn.cursor()
    cur.execute(sql_update)
    conn.commit()
    cur.close()

# set has_quality_metric boolean to TRUE for variable in exposure_list
sql_update = "UPDATE exposure_list " \
             "SET has_quality_metric = TRUE " \
             "WHERE VARIABLE = '" + variable + "';"
print('  -- ' + sql_update)
cur = conn.cursor()
cur.execute(sql_update)
conn.commit()
cur.close()

conn.close()
