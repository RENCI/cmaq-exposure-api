from configparser import ConfigParser
import psycopg2
import sys
import csv

dbcfg = ConfigParser()
dbcfg.read('../../config/database.ini')

try:
    file_name = sys.argv[1]
    variable = sys.argv[2]
except Exception as e:
    print('Usage: python ingest-quality-metrics.py FILENAME VARIABLE')
    print(e)
    sys.exit(1)

try:
    conn = psycopg2.connect("dbname='" + dbcfg.get('postgres', 'database') +
                            "' user='" + dbcfg.get('postgres', 'username') +
                            "' host='" + dbcfg.get('postgres', 'host') +
                            "' password='" + dbcfg.get('postgres', 'password') +
                            "' port='" + dbcfg.get('postgres', 'port') +
                            "'")
except psycopg2.OperationalError as e:
    print(e)
    sys.exit(1)

# if exposure_list doesn't have the has_quality_metric column, add it and default to FALSE
sql = "SELECT column_name " \
      "FROM information_schema.columns " \
      "WHERE table_name='exposure_list' " \
      "and column_name='has_quality_metric';"
cur = conn.cursor()
cur.execute(sql)
if not cur.fetchall():
    print('Adding column: data_quality')
    sql_add = "ALTER TABLE exposure_list ADD COLUMN IF NOT EXISTS has_quality_metric BOOLEAN DEFAULT FALSE;"
    print('  -- ' + sql_add)
    cur = conn.cursor()
    cur.execute(sql_add)
    conn.commit()
    cur.close()
else:
    print('has_quality_metric: Already defined')

# Additional data quality metrics generated by CMAQ have been commented out, but could be activated at a later date
sql = "SELECT variable FROM quality_metrics_list;"
cur = conn.cursor()
cur.execute(sql)
variables = cur.fetchall()
dq_metrics = []
for var in variables:
    dq_metrics.append(str(var[0]))

"Date","CMAQ_2010_36k_base_Obs_Average","CMAQ_2010_36k_base_Model_Average","CMAQ_2010_36k_base_Bias_Average","CMAQ_2010_36k_base_RMSE_Average","CMAQ_2010_36k_base_Corr_Average"

dq_dict = {}
with open(file_name) as f:
    reader = csv.reader(f)
    headers = next(reader)
    print(headers)
    for dq in dq_metrics:
        dq_dict[dq] = "\n".join(s for s in headers if dq.lower() in s.lower())
    print(dq_dict)

conn.close()
sys.exit(0)

# Need ot resolve DQ naming between provided files and CSV before proceeding

with open(file_name) as f:
    reader = csv.DictReader(f)
    for row in reader:
        print(row)
        # check if date-time row already exists
        sql = "SELECT * FROM quality_metrics_data WHERE utc_date_time = '" + row['Date'] + "';"
        cur = conn.cursor()
        cur.execute(sql)
        if not cur.fetchall():
            dq_vars = ''
            dq_vals = '\'' + str(row['Date']) + '\', '
            for dq in dq_metrics:
                dq_vars += variable + '_' + dq + ', '
                dq_vals += str(row[str(dq_dict[dq])]) + ', '
            sql_stmt = "INSERT INTO quality_metrics_data " \
                      "(utc_date_time, " + dq_vars[:-2] + ") " \
                      "VALUES (" + dq_vals[:-2] + ");"
        else:
            dq_vals = ''
            for dq in dq_metrics:
                dq_vals += variable + '_' + dq + ' = ' + str(row[str(dq_dict[dq])]) + ', '
            sql_stmt = "UPDATE quality_metrics_data " \
                       "SET " + dq_vals[:-2] + " " \
                       "WHERE utc_date_time = '" + row['Date'] + "';"
        print('  -- ' + sql_stmt)
        cur.execute(sql_stmt)
        conn.commit()
        cur.close()

# set data_quality boolean to TRUE for variable in exposure_list
sql_update = "UPDATE exposure_list " \
             "SET has_quality_metric = TRUE " \
             "WHERE variable = '" + variable + "';"
print('  -- ' + sql_update)
cur = conn.cursor()
cur.execute(sql_update)
conn.commit()
cur.close()

conn.close()
